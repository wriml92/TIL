# CS50x 2주차: 배열 - 오늘 배운 내용

## 소개

오늘 하버드의 CS50x 과정 2주차를 공부했는데, 이번 주는 배열에 초점을 맞추고 있습니다. 1주차의 C 기초에서 더 나아가, 이번 주는 프로그램에서 데이터가 어떻게 저장되고 조작되는지에 대한 이해를 넓혔습니다. 강의는 컴파일부터 명령행 인자까지 여러 핵심 개념을 다루었으며, 배열과 문자열이 중심 주제였습니다.

## 컴파일 과정

우리가 사용해온 간단한 `make` 명령어가 실제로는 코드를 컴파일할 때 일어나는 복잡한 4단계 과정을 숨기고 있다는 것을 배웠습니다:

1. **전처리(Preprocessing)**: 첫 번째 단계는 `#include` 지시문을 처리하여 `<stdio.h>`와 `<cs50.h>` 같은 헤더 파일에서 코드를 가져와 우리 코드에 복사하는 것입니다.

2. **컴파일(Compiling)**: 컴파일러는 C 코드를 어셈블리 언어로 변환합니다. 어셈블리 언어는 기계 명령어의 사람이 읽을 수 있는 표현입니다.

3. **어셈블(Assembling)**: 어셈블러는 어셈블리 언어를 컴퓨터가 직접 실행할 수 있는 기계어(이진 0과 1)로 변환합니다.

4. **링킹(Linking)**: 마지막 단계는 우리의 기계어 코드와 사용 중인 라이브러리의 코드를 결합하여 하나의 실행 파일을 생성합니다.

흥미로웠던 점은 `make hello`를 사용할 때, 실제로는 뒤에서 `clang -o hello hello.c -lcs50`와 같은 명령어가 실행된다는 것입니다.

## 디버깅 기법

강의에서는 디버깅의 두 가지 주요 접근 방법을 강조했습니다:

1. **print 문 사용하기**: 코드의 다양한 단계에서 변수 값을 출력하여 무슨 일이 일어나고 있는지 확인하는 빠르지만 때로는 지저분한 방법입니다.

2. **디버깅 도구 사용하기**: 실행을 일시 중지하고, 변수 값을 추적하며, 코드를 한 줄씩 실행할 수 있는 더 체계적인 접근 방법입니다.

그동안 print 문에 너무 의존해왔다는 것을 깨달았고, 실제 디버깅 도구를 더 많이 연습해야겠다고 생각했습니다. 블로그 포스트 중 하나가 언급했듯이, "작던 크던 디버깅 도구가 지원되는 환경에서는 디버깅 도구를 사용해 버릇하는게 나의 목표이다."

## 메모리와 배열

오늘 배운 가장 중요한 개념 중 하나는 배열이 메모리에 데이터를 저장하는 방식이었습니다:

- 다양한 데이터 타입은 서로 다른 양의 메모리를 차지합니다:
  - bool: 1바이트
  - int: 4바이트
  - long: 8바이트
  - float: 4바이트
  - double: 8바이트
  - char: 1바이트
  - string: 가변적(길이에 따라 다름)

- 배열은 연속적인 메모리 블록을 할당하며, 요소들은 나란히 저장됩니다.

- `int scores`와 같은 배열을 선언할 때, 우리는 12바이트의 블록(3개의 정수 × 4바이트)을 예약하는 것입니다.

이것은 배열이 인덱스로 요소에 접근하는 데 효율적인 이유를 이해하는 데 도움이 되었습니다 - 컴퓨터는 시작점과 각 요소의 크기를 기반으로 정확한 메모리 위치를 계산할 수 있습니다.

## C에서의 문자열

문자열에 대한 설명이 특히 유익했습니다:

1. C에서 문자열은 실제로 문자의 배열입니다.

2. C의 문자열은 '널 종결자'(`\0`)라는 특수 문자로 끝납니다. 이것은 1바이트를 차지하며 컴퓨터에게 문자열이 어디서 끝나는지 알려줍니다.

3. 이는 "HI!"와 같은 문자열이 실제로 메모리에 4바이트(3개의 문자와 널 종결자)를 차지한다는 것을 의미합니다.

4. 널 종결자는 `strlen()` 함수가 문자열의 길이를 결정할 수 있는 이유를 설명합니다 - 널 종결자에 도달할 때까지 문자를 세는 것입니다.

이 문자열-배열 개념은 `string[i]`와 같은 구문을 사용하여 개별 문자에 접근할 수 있는 이유를 설명합니다.

## 명령행 인자

오늘 명령행 인자에 대해서도 배웠습니다. 명령행 인자는 프로그램이 터미널에서 실행될 때 입력을 받을 수 있게 해줍니다:

1. 명령행 인자를 사용하려면 `int main(void)`를 `int main(int argc, string argv[])`로 변경합니다.

2. `argc`는 인자 개수(제공된 인자의 수)입니다.

3. `argv`는 인자를 포함하는 문자열 배열입니다.

4. `argv`은 항상 프로그램 자체의 이름이므로, 실제 인자는 `argv`부터 시작합니다.

이것은 명령줄에서 직접 제어할 수 있는 프로그램을 만드는 데 유용할 것입니다.

## 문제 세트

2주차 문제 세트에는 다음이 포함됩니다:

1. **Scrabble**: 배열을 사용하여 글자 값을 저장하고 Scrabble 단어의 점수를 계산합니다.

2. **Readability**: 계산 알고리즘을 사용하여 텍스트를 분석하여 읽기 수준을 결정합니다.

3. **Substitution**: 제공된 키에 따라 문자를 대체하는 암호를 구현합니다.

Scrabble 문제가 특히 흥미로웠는데, 배열이 어떻게 값(이 경우에는 글자 점수)을 효율적으로 찾는 데 사용될 수 있는지 명확하게 보여주기 때문입니다.

## 성찰

배열은 데이터 컬렉션을 효율적으로 다룰 수 있게 해주는 프로그래밍의 기본 개념입니다. 문자열이 널 종결자와 함께 문자 배열로 구현되는 방식은 이의 특히 우아한 예입니다.

한 블로그 포스트에서 언급했듯이, "백문이 불여일타" - 이 속담은 오늘 제 경험을 잘 담아냅니다: 배열에 대해 읽는 것은 한 가지이지만, 실제로 코드에서 구현해 보는 것이 개념을 훨씬 더 구체적으로 만들어 주었습니다.

배열과 문자열에 대해 배운 내용을 실제로 적용할 수 있는 Scrabble 챌린지를 포함한 문제 세트에 도전하는 것이 기대됩니다.

## 왜 이것이 중요한가

메모리에서 배열이 작동하는 방식을 이해하는 것은 효율적인 코드를 작성하는 데 중요하며, 문자열 개념은 프로그래밍에서 텍스트 처리의 기초를 형성합니다. 이러한 기본 개념은 앞으로 몇 주 동안 더 복잡한 주제로 넘어갈 때 필수적일 것입니다.

다음 세션을 위한 제 목표는 디버깅 도구에 더 익숙해지고, 깔끔하고 잘 구조화된 코드로 문제 세트를 완성하는 것입니다.