**TIL (Today I Learned): Array와 LinkedList**

---

## 1. Array(배열)

### (1) 배열이란?
- **연속된 메모리** 공간에 **동일한 타입**의 데이터를 일렬로 저장하는 자료구조예요.  
- 인덱스(0, 1, 2, ...)로 각 요소에 직접 접근이 가능해서, **임의 접근(Random Access)** 속도가 빠릅니다.

### (2) 주요 특징
1. **빠른 접근**  
   - 인덱스로 즉시 계산해 해당 위치의 요소에 접근 가능 → **O(1)** 시간  
   - 예: `arr[5]` 하면 바로 6번째 요소를 읽거나 쓸 수 있음.
   
2. **삽입/삭제 비용**  
   - 정해진 위치에서 삽입하거나 삭제할 때 **나머지 요소들**을 한 칸씩 밀거나 땡겨야 해서, 최악의 경우 **O(n)**  
   - 배열의 앞쪽이나 중간에 새로운 값을 넣으려면 많은 요소를 움직여야 함.
   
3. **고정 크기 혹은 동적 크기**  
   - 일반적인 저수준 언어(C, C++ 등)에서는 **배열 크기가 고정**되어 있음  
   - 고급 언어(Python list, Java ArrayList 등)에서 내부적으로 배열을 사용하지만, **자동으로 크기가 확장**될 수도 있음(이를 위해 별도의 재할당 과정이 일어남).

### (3) 언제 쓰면 좋은가?
- **랜덤 접근**이 빈번하고, 삽입/삭제는 드물거나 주로 **배열 끝에서**만 일어나는 경우에 효율적  
- 예: 인덱스로 특정 항목을 자주 조회하는 경우, 또는 스택/큐처럼 마지막에만 삽입/삭제를 주로 하는 구조(동적 배열).

---

## 2. LinkedList(연결 리스트)

### (1) 연결 리스트란?
- 요소(노드)들이 각각 **다음 요소의 주소**(포인터, 링크)를 보유해, **연결 구조**를 이루는 자료구조예요.  
- 메모리가 **연속적이지 않아도** 되고, **동적 메모리 할당**이 용이함.

### (2) 주요 특징
1. **삽입/삭제 용이**  
   - 특정 노드의 **링크**를 조작해서 요소를 끼우거나 뺄 수 있어, 해당 노드 위치만 안다면 O(1)에 삽입/삭제 가능  
   - 단, 노드를 찾기 위해서는 선형적으로 탐색해야 하므로 그 과정이 O(n)일 수 있음.

2. **순차 접근(Sequential Access)**  
   - 첫 노드부터 링크를 타고 차례대로 탐색해야 해요 → 임의 접근(Random Access)은 **O(n)**  
   - 인덱스로 즉시 접근하는 배열과 달리, i번째 노드를 가려면 i번 링크를 따라가야 함.

3. **메모리 분산 저장**  
   - 연속된 공간이 필요 없어, **동적**으로 확장 가능(노드를 그때그때 할당)  
   - 포인터 저장 비용이 들고, 캐시 효율이 배열보다 떨어질 수 있다는 단점도 있음.

### (3) 언제 쓰면 좋은가?
- 삽입/삭제가 **빈번**하거나 **중간 위치**에서도 쉽게 일어나야 할 때  
- 예: 구현 수준에서 **Queue**(단방향 연결 리스트의 Head/Tail)나 **LRU 캐시**(요소를 빠르게 빼고 넣어야 하는 구조) 등에서 유용.

---

## 3. 비교 요약

| 항목             | Array                       | LinkedList                                |
|-----------------|-----------------------------|-------------------------------------------|
| 메모리 구조      | 연속된 공간                | 분산된 노드들이 링크로 연결              |
| 접근 속도        | **Random Access: O(1)**    | 순차 접근: O(n)                          |
| 삽입/삭제        | 앞/중간: O(n), 끝: O(1)    | 노드 참조 시: O(1), 노드 탐색은 O(n)     |
| 메모리 사용 효율 | 데이터만 저장 (오버헤드↓) | 포인터(링크) 저장 때문에 오버헤드↑       |
| 사용 예시        | 인덱스 접근이 많은 경우    | 빈번한 중간 삽입/삭제, 동적 변동 구조     |

---

## 4. 오늘 배운 점
- **배열**은 **인덱스 접근**이 빠르고 단순한 구조지만, **중간 삽입/삭제**가 비용이 큰 자료구조.  
- **연결 리스트**는 **연결(포인터)로 노드를 체인**처럼 엮는 방식이라, 삽입/삭제가 편한 대신, 한 번에 i번째 요소에 뛰어갈 수 없는 단점이 있음.  
- 따라서 어떤 상황에 쓰이느냐(랜덤 접근 vs. 삽입/삭제 빈도)에 따라 **적절한 자료구조**를 골라야겠다는 생각이 든다.  
- 실제 고급 언어 라이브러리(Python list/collections.deque, Java ArrayList/LinkedList) 등에서 이 개념들이 응용되어 있다.

---

### 한 줄 요약
“Array는 **연속 메모리**로 **빠른 인덱스 접근**에 강점이 있고, LinkedList는 **포인터로 연결**돼 **삽입/삭제**가 용이하지만 임의 접근은 느리다는 점이 특징이다.”