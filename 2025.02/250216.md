**TIL (Today I Learned): Django에서 발생하는 AssertionError**

---

## 1. AssertionError란?
- 파이썬의 **내장 예외** 중 하나로, `assert` 문에서 지정한 조건이 거짓일 때 일어나요.  
- Django 프로젝트에서도, **Django 내부 코드** 혹은 **개발자가 직접 쓴 assert 문**이 실패하면 이 예외가 발생.  
- “**절대 이 상황이 일어나서는 안 된다**”고 가정한 조건이 깨졌을 때, 프로그래머의 **논리 오류**나 **환경 문제**를 알려주는 용도로 주로 쓰입니다.

---

## 2. Django에서 발생하는 시나리오 예시

1. **Django 내부 코드의 가정이 깨졌을 때**  
   - 장고 ORM, 미들웨어, 템플릿 엔진 등에서 **예상치 못한** 상황을 만날 경우, 내부에서 `assert`로 체크해 에러를 띄울 수 있음.  
   - 예: “이 함수는 GET 요청일 때만 호출되어야 한다” 라고 가정한 곳에서 POST 요청이 들어오면, `AssertionError` 발생.

2. **테스트 코드에서 `assert` 사용**  
   - Django 테스트(TestCase 등) 작성 시, 개발자가 **직접** `assert 조건`을 걸어두고 특정 로직이 실패하면 `AssertionError` 발생.  
   - 예: `assert user.is_active, "User should be active by default!"`

3. **잘못된 설정이나 구조**  
   - settings.py나 apps.py 등에서 **비정상** 설정이 감지되면, Django가 시작 과정에서 `AssertionError`로 알리기도 함.  
   - 예: “SECRET_KEY가 설정되지 않았으면 안 된다” 라는 형태로, 내부에서 `assert SECRET_KEY`를 검사할 수 있음(버전별로 다를 수 있지만, 유사한 체크 로직 존재).

---

## 3. 주의할 점

1. **개발 환경 vs 운영 환경**  
   - 보통 `assert` 문은 **디버깅**이나 **개발 모드**에서 유용.  
   - 운영 환경(프로덕션)에서는 `assert`가 최적화에 의해 무시될 수도 있기 때문에, **치명적 로직**을 전적으로 `assert`에 의존하면 안 됨.

2. **명확한 에러 메시지**  
   - `assert some_condition, "명확한 오류 설명"`처럼 작성해야, 문제 발생 시 **디버깅**이 쉬움.  
   - “왜 이 assert가 있는지”를 주석 혹은 메시지로 남겨두면, 나중에 원인 파악이 빨라짐.

3. **AssertionError vs ValidationError / 기타**  
   - 모델이나 폼에서 일반적인 데이터 검증 실패는 `ValidationError`를 사용하는 게 권장.  
   - `AssertionError`는 “내부적으로 절대 깨지지 않아야 하는 논리적 가정”을 보장하기 위한 용도로 쓰는 편이 맞아요.

---

## 4. 오늘 배운 점
- Django에서 `AssertionError`는 기본적으로 파이썬의 `assert` 문이 실패할 때 나오는 예외이며, Django 내부 코드나 직접 작성한 부분에서 “**이건 절대 거짓이 되면 안 돼**”라는 조건이 깨졌을 때 발생한다고 이해했습니다.  
- 일반 데이터 검증(사용자 입력 등)보다는 “**논리적 불변성**”을 보장하려는 용도에 더 어울리는 예외네요.  
- 프로덕션 환경에서는 `assert`가 무시될 수도 있으므로, 정말 중요한 방어 로직이라면 `if not condition: raise SomeError` 식으로 명시적으로 처리하는 게 안전하다는 것도 기억해야겠어요.

---

### 한 줄 요약
“Django에서 발생하는 AssertionError는, **assert** 문이 실패했을 때 뜨는 예외로, 주로 ‘절대 깨지지 않을 조건’이 위배됐음을 알리며, 데이터 검증보다는 **논리적 가정 보장** 목적으로 쓰인다.”