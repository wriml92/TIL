&emsp;웹 애플리케이션에서 사용자 인증(Authentication)과 권한 부여(Authorization)를 구현하는 대표적인 방법으로 세션(Session)과 **토큰(Token) 인증 방식**이 있다. 이 두 방식은 사용자가 로그인한 상태를 유지하고, 보호된 리소스에 대한 접근 권한을 관리하기 위해 활용된다. 각각의 개념, 동작 원리, 장단점, 사용 시나리오에 대해 자세히 알아보자.

## 1. 세션(Session) 방식 인증

### 개념  
&emsp;세션 인증 방식은 서버 측에 사용자 상태(로그인 상태, 사용자 정보)를 저장해 두고, 사용자가 이후 요청 시 세션 식별 정보(세션 ID)를 전송하면, 서버는 해당 세션 정보를 통해 사용자를 식별하고 접근을 허용하는 방식이다.

### 동작 원리  
1. **로그인 요청**: 사용자가 아이디/비밀번호로 로그인 요청을 하면, 서버는 해당 자격 정보를 검증한다.  
2. **세션 생성**: 인증 성공 시 서버는 고유한 **세션 ID**를 생성하고, 이를 서버 측 메모리나 데이터스토어(Redis, 데이터베이스) 등지에 저장한다. 그 세션 ID에는 사용자 식별 정보, 권한 수준 등의 정보를 맵핑해 둔다.  
3. **쿠키 전송**: 서버는 응답 헤더에 세션 ID를 담은 쿠키를 브라우저에게 전송한다(보통 `Set-Cookie` 헤더).  
4. **요청 시 세션 검증**: 이후 사용자는 요청을 보낼 때 자동으로 쿠키에 담긴 세션 ID를 서버에 전송한다. 서버는 해당 세션 ID를 통해 세션 스토어에서 사용자 정보를 조회하고, 인증/인가 여부를 판단한다.  
5. **세션 만료**: 일정 시간 동안 요청이 없거나 명시적으로 로그아웃하면, 서버 측에서 해당 세션을 삭제해 더 이상 유효하지 않게 한다.

### 특징  
- **서버 상태 유지**: 서버가 세션 상태를 저장하므로 스테이트풀(Stateful)한 구조를 가진다. 즉, 서버는 특정 세션ID에 해당하는 사용자 상태를 기억하고 있어야 한다.  
- **규모 확장 난이도**: 서버 확장 시 세션 공유를 위해 세션 스토어(예: Redis, Memcached)나 세션 스티키(Sticky Session) 로드 밸런싱 설정이 필요하다.  
- **보안**: 세션 ID가 쿠키에 저장되므로 HTTPS를 통한 전송암호화와 HttpOnly, Secure 플래그 설정이 중요하다.  
- **내부망용 서비스나 소규모 서비스**에서 비교적 간단히 구현 가능.

## 2. 토큰(Token) 기반 인증

### 개념  
&emsp;토큰 기반 인증은 서버가 사용자를 인증한 후, 별도의 상태 저장 없이 클라이언트에게 **토큰(문자열 형태의 인증 정보)**을 발급하고, 이후 클라이언트가 이 토큰을 요청 시 전송하면 서버가 토큰 유효성을 검증하는 방식이다. 이 때 서버는 사용자의 상태를 별도로 저장하지 않고, 토큰 자체에 필요한 정보나 검증 수단을 포함시킨다(대표적으로 JWT: JSON Web Token).

### 동작 원리 (JWT를 예로 들면)  
1. **로그인 요청**: 사용자가 로그인 시 자격 증명을 서버에 전송한다.  
2. **토큰 발급**: 인증 성공 시 서버는 사용자 식별 정보(예: user id, role) 등을 JWT 페이로드에 담고, 비밀키를 사용해 서명하여 토큰을 생성한 뒤 클라이언트에 반환한다.  
3. **토큰 저장**: 클라이언트(브라우저, 모바일 앱)는 이 토큰을 로컬 저장소(localStorage), 세션 스토리지, 혹은 메모리에 보관한다.  
4. **요청 시 토큰 전송**: 이후 요청할 때마다 클라이언트는 HTTP 헤더(일반적으로 `Authorization: Bearer <token>`)에 토큰을 담아 서버로 전송한다.  
5. **서버 검증**: 서버는 해당 토큰을 받은 뒤 서명을 검증하고, 토큰 내 페이로드의 유효성(만료 시간 등)을 확인하여 인증/인가를 결정한다.  
6. **토큰 만료 관리**: 토큰은 만료 시간이 포함되며, 만료 시 클라이언트는 재인증이 필요하다. 유효기간 중간에 권한을 철회하는 로직 구현 시, 토큰 블랙리스트 관리 등을 고려할 수 있다.

### 특징  
- **서버 상태 비저장(Stateless)**: 서버는 사용자의 인증 상태를 저장하지 않고, 요청 시 토큰 검증만 수행하므로 확장성(Scalability)이 뛰어나다.  
- **확장과 분산에 유리**: 여러 서버 인스턴스가 있을 때도 토큰 검증만 하면 되므로 세션 공유 문제가 없다.  
- **토큰 취약성 관리 필요**: 토큰이 탈취되면 만료 전까지 유효하므로, 토큰 보관을 안전하게 하고 HTTPS로 전송해야 한다.  
- **모바일/SPA(싱글 페이지 애플리케이션) / API 서비스** 등 분산 아키텍처에 선호.

## 3. 세션과 토큰 방식 비교

| 구분 | 세션 기반 인증 | 토큰 기반 인증 |
| ---- | -------------- | -------------- |
| 상태 유지 | 서버가 세션 저장 (Stateful) | 서버 비저장 (Stateless) |
| 확장성 | 세션 공유 또는 스티키 세션 필요, 수평 확장 어려움 | 토큰 검증만 하면 되어 확장성 좋음 |
| 저장 위치 | 서버 메모리/스토어에 세션 | 클라이언트가 토큰 보관 |
| 성능 | 서버 측 조회 필요 | 서명 검증으로 빠름, 그러나 서명 검증 비용 존재 |
| 만료 관리 | 세션 만료 시 서버에서 세션 제거 | 토큰 만료 시간 내 유효, 만료 전 강제 무효화 어렵지만 블랙리스트나 토큰 회전 전략 가능 |
| 활용 사례 | 전통적인 웹 애플리케이션, 작은 규모 | 마이크로서비스, SPA, 모바일 앱, API 게이트웨이 환경 |

## 4. 어느 방식을 선택해야 할까?

- **세션 기반**:  
  - 서버 측에서 상태 관리가 용이하고, 서버와 클라이언트 사이 1:1 관계가 명확한 전통적인 웹 애플리케이션에 적합하다.
  - 단일 서버 또는 적은 수의 서버, 내부망 서비스에 편리하다.

- **토큰 기반(JWT 등)**:  
  - 클라이언트가 다양하고(모바일, 웹, IoT), 서버가 다수이며, 마이크로서비스 아키텍처나 클라우드 환경에서 확장성이 중요할 때 적합하다.
  - 공개 키 기반 서명 검증을 통해 신뢰할 수 있는 인증/인가 모델을 구성할 수 있어 다른 서비스 간 SSO, 인증 공유에도 용이하다.

---

**정리**:  
- **세션**: 서버에 사용자 상태를 저장하는 전통적 방식. 간단한 환경에서 구현하기 쉽지만, 수평 확장에 제약이 있다.  
- **토큰**: 서버 비저장 방식으로 확장성과 API 중심 아키텍처에 유리. 다만 토큰 보안 관리와 만료 전 철회 같은 추가 로직이 필요할 수 있다.

&emsp;프로젝트 성격, 인프라 규모, 확장성 요구사항, 클라이언트 종류 등을 종합적으로 고려해 선택하는 것이 좋다.