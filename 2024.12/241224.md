&emsp;페이지네이션(Pagination)은 여러 개의 데이터를 한꺼번에 모두 노출하는 대신, 여러 페이지로 나누어 일정 개수씩만 보여주는 기법이다. 예를 들어, 게시판이나 검색 결과 페이지에서 한 번에 수백~수천 개의 결과를 모두 로드하면 성능 저하 및 사용자 혼란이 발생할 수가 있으므로, 한 페이지에 10개, 20개, 50개 등의 항목만 노출하고 나머지는 다음(이전) 페이지로 넘기게 하는 것이 페이지네이션의 대표적인 사례이다.

&emsp;이제부터 페이지네이션의 주요 필요성, 방법, 구성 요소, 고려사항 등을 자세히 알아보자.

---

## 1. 페이지네이션의 필요성

1. **성능 및 자원 절감**  
   - 서버가 한 번에 모든 데이터를 내려주면, 네트워크 트래픽이 커지고 처리 시간이 길어진다.  
   - 페이지별로 일부 데이터만 전송하면, 서버 부하와 네트워크 전송량을 줄일 수 있다.

2. **사용자 경험(UX) 향상**  
   - 방대한 데이터를 한 화면에 모두 보여주면, 사용자는 스크롤이 길어져 탐색이 불편해진다.  
   - 페이지 단위로 구분하면 사용자는 정보를 쉽게 찾고, 다음/이전 페이지 이동 등을 통해 데이터를 순차적으로 확인할 수 있다.

3. **API 응답 규모 제한**  
   - REST API, GraphQL API 등에서도 무한정 많은 데이터를 요청하면 성능 문제가 심각해질 수 있다.  
   - 페이지네이션 매개변수(limit, offset, page 등)를 사용해 요청 단위 및 응답 크기를 제어한다.

---

## 2. 페이지네이션 구현 방식

### 2.1 Offset 기반 페이지네이션

- **개념**  
  - 쿼리 파라미터로 `offset`(시작 위치)과 `limit`(가져올 데이터 개수)를 전달하여 데이터베이스 쿼리를 수행한다.  
  - 예) `GET /users?offset=20&limit=10`  
    - 20번째 행부터 10개의 레코드를 가져와 2페이지(21~30번 사용자)에 해당하는 데이터를 노출한다.

- **특징**  
  - 구현이 쉽고 직관적이다.  
  - 대량의 데이터 테이블에서 `OFFSET`값이 커질수록 DB 내부에서 불필요한 스캔 비용이 증가할 수 있다.  
  - 레코드가 중간에 추가/삭제되면, offset이 변동되어 “데이터가 밀리는” 현상이 발생할 수 있다(시간순 정렬에서 최신 데이터가 끼어드는 상황 등).

### 2.2 Cursor 기반 페이지네이션

- **개념**  
  - 데이터를 특정 정렬 기준(예: id, created_at)에 따라 순서대로 정렬하고, 현재 페이지의 마지막 레코드의 키(key)를 “커서”로 삼아, 다음 요청 시 이 커서 이후의 데이터를 가져오는 방식이다.  
  - 예) `GET /users?cursor=abcdef`  
    - `cursor`가 가리키는 레코드 이후부터 limit개를 가져온다.

- **특징**  
  - 항목이 추가/삭제되어도 일관된 순서를 유지하기 쉽다.  
  - 성능 면에서 Offset 방식보다 효율적일 수 있다(DB에서 정렬 키 기반 탐색).  
  - 커서를 어떻게 인코딩/디코딩할지, 정렬 필드가 무엇인지에 대한 설계가 필요하다.

### 2.3 페이지 번호 기반(page-based) 페이지네이션

- **개념**  
  - 사용자가 흔히 보는 UI와 유사한, “1페이지, 2페이지, 3페이지...”와 같은 접근을 의미한다.  
  - 예) `GET /users?page=2&page_size=20`

- **특징**  
  - 직관적이지만, 내부적으로 DB에서 구현 시 Offset 기반으로 처리되는 경우가 많다.  
  - 대규모 데이터에서 페이지 번호가 커질수록 Offset 비용이 증가할 수 있다.  
  - UI 구현에는 편리하나, 데이터가 실시간으로 변경될 때 페이지 번호에 따른 정합성을 보장하기가 어렵다.

---

## 3. 페이지네이션 구성 요소

1. **총 아이템 수(total_count)**  
   - 전체 데이터가 몇 개인지 나타내며, 페이지네이션 UI(“총 n개” 문구, 전체 페이지 수 산출)나 클라이언트 계산에 활용된다.  
   - 예) `200`개의 게시글이 있다면, 페이지 사이즈가 `10`일 때 총 페이지 수는 `20`이다.

2. **현재 페이지 정보**  
   - 사용자가 현재 몇 번째 페이지에 있는지(page=2 등), 또는 현재 커서가 어디를 가리키는지(cursor=...).

3. **페이지 크기(page_size / limit)**  
   - 한 페이지에 몇 개의 항목을 보여줄지 지정한다.  
   - 보통 기본값과 최대값(max limit)을 정의하여 클라이언트가 과도하게 큰 페이지를 요청하지 못하도록 제약한다.

4. **이전/다음 링크**  
   - UX를 위해 `previousPage`, `nextPage` URL을 응답에 포함시킬 수 있다.
   - Cursor 기반에서는 다음 커서, 이전 커서를 적절히 계산해 전달한다.

5. **정렬 기준(주로 최신순, 오름차순 등)**  
   - 게시글일 경우 `created_at DESC`, 사용자 목록이라면 `id ASC` 등, 페이지네이션 시 일관된 정렬이 중요하다.  
   - Cursor 기반에서는 정렬 필드가 필수적으로 존재해야 한다.

---

## 4. 구현 예시

### 4.1 Django REST Framework(DRF) 예시

- **settings.py**:  
  ```python
  REST_FRAMEWORK = {
      'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
      'PAGE_SIZE': 10,
  }
  ```
  - 이렇게 설정하면 DRF에서 자동으로 `/?page=2`와 같은 쿼리 파라미터로 페이지네이션이 적용된다.
  - `LimitOffsetPagination`, `CursorPagination` 등 다른 클래스를 활용할 수도 있다.

- **View 코드**:  
  ```python
  from rest_framework import generics
  from .models import Post
  from .serializers import PostSerializer

  class PostListAPIView(generics.ListAPIView):
      queryset = Post.objects.all().order_by('-created_at')
      serializer_class = PostSerializer
      # 페이지네이션 설정은 settings.py 또는 클래스 내부 pagination_class에서 지정
  ```
  - DRF가 페이지네이션 정보를 응답 JSON에 함께 내려줌(`count`, `next`, `previous`, `results` 등).

### 4.2 Query 예시 (Offset 기반)

- **SQL**:  
  ```sql
  SELECT * 
  FROM posts
  ORDER BY created_at DESC
  LIMIT 10 OFFSET 20;
  ```
  - 21번째부터 30번째 게시물을 가져온다.

### 4.3 Cursor 기반 예시

- 클라이언트가 `cursor=2023-08-01T00%3A00%3A00Z`와 `limit=10` 등으로 요청한다:  
  ```bash
  GET /posts?cursor=2023-08-01T00%3A00%3A00Z&limit=10
  ```
  - 서버는 내부 로직에서 `created_at > cursor` 조건(또는 `< cursor`, 정렬 방향에 따라 달라짐)을 이용해 10개를 가져온다.  
  - 다음 요청을 위한 새 `next_cursor`를 응답에 넣어 보낸다.

---

## 5. 페이지네이션 시 고려사항

1. **데이터 변경(동시성) 문제**  
   - 데이터가 실시간으로 추가되거나 삭제될 경우, 페이지네이션 순서나 페이지 수가 달라질 수 있다. 특히 Offset 방식에서 “밀리는” 문제가 크다.
   - 권장 방법: Cursor 기반 페이지네이션, 타임스탬프나 고유 ID 순 정렬을 사용하면 일관성을 어느 정도 확보할 수 있다.

2. **응답 성능**  
   - 큰 offset일 때, DB가 불필요하게 앞 레코드를 스캔해야 하는 비용이 있을 수 있다(예로는 MySQL, PostgreSQL 등이 있다).  
   - 인덱스 최적화, 커버링 인덱스, Cursor 방식 등을 통해 문제를 완화할 수 있다.

3. **사용자 경험(UI/UX)**  
   - 한 화면에 몇 개 정도 보여줄지 결정, “다음/이전” 버튼 외에 페이지 번호를 노출할지, 무한 스크롤(Infinite scroll)을 적용할지 등을 고민해야 한다.  
   - 모바일 환경에서는 무한 스크롤이 자주 쓰이지만, 성능 및 히스토리 관리(뒤로가기 시 위치 기억 등) 측면에서 주의가 필요하다.

4. **API 인터페이스 표준화**  
   - REST API 설계 시, `GET /resources?page=1&page_size=20` 또는 `GET /resources?offset=0&limit=20`처럼 프로젝트 내 일관된 파라미터 이름과 응답 구조를 정의하면 좋다.
   - Pagination 관련 정보를 응답에 어떻게 포함할지도 미리 정한다(`total_count`, `next`, `previous`, `current_page`, `results`, etc.).

5. **클라이언트 측 캐싱**  
   - 페이지네이션 결과도 브라우저나 CDN에서 캐싱하는 시나리오가 있을 수 있다. 페이지 번호 또는 Cursor 값마다 캐싱 키가 달라질 수 있고, 데이터 변경이 자주 일어나는 서비스에서는 캐싱 전략이 복잡할 수 있다.

---

## 6. 마무리

&emsp;페이지네이션은 대규모 데이터를 다루는 대부분의 웹·모바일 애플리케이션에서 필수적인 기능이다.  
- **Offset 기반**: 간단하고 직관적이지만, 데이터 변경이 잦고 대규모 데이터 테이블에는 비효율이 있을 수 있다.  
- **Cursor 기반**: 대형 서비스나 실시간성이 중요한 서비스에서 권장되는 방식으로, 데이터 일관성과 성능에 이점이 있다.  
- **페이지 번호 기반**: 사용자 UI에 친숙하며, 내부적으로 Offset을 사용할 때가 많다.

&emsp;어떤 방식이든, 성능 요구사항과 데이터 일관성, 사용자 편의 등을 종합적으로 고려해 최적의 페이지네이션 설계를 해야 한다.