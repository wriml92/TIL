&emsp;**JWT**(JSON Web Token)는 웹 표준(RFC 7519)으로 정의된 방식으로, 서로 신뢰 관계에 있는 시스템 간에 JSON 객체 형태로 **인증(Authorization)** 혹은 **정보 교환**에 사용되는 **간단하고 안전한 토큰(Token) 기반**의 구조이다. 일반적으로 **사용자 인증**이나 **서버 간 통신**에서 클라이언트가 서버에 요청을 보낼 때 “이 사용자가(혹은 이 요청이) 적법한가?”를 증명하기 위해 사용된다. 예를 들어, 사용자가 로그인에 성공하면, 서버는 사용자 정보를 포함한 JWT를 발급하고, 클라이언트는 이후의 요청 헤더에 JWT를 첨부함으로써 해당 사용자가 인증되었음을 증명할 수 있다.

&emsp;이제부터 JWT의 구성, 동작 원리, 장단점, 보안 고려사항 등에 대해 자세히 알아보자.

---

## 1. JWT의 구조

&emsp;JWT는 일반적으로 `헤더(Header)`, `페이로드(Payload)`, `서명(Signature)` 이렇게 세 부분이 `.`(점)으로 구분되어 연결된 문자열 형태이다. 예:

```
xxxxx.yyyyy.zzzzz
```

1. **헤더(Header)**  
   - JWT 유형(JWT)과 서명 알고리즘(HMAC SHA256, RSA 등) 정보를 담고 있다.  
   - JSON 형태이지만, 최종적으로 Base64Url로 인코딩되어 문자열화된다.  
   - 예시:
     ```json
     {
       "alg": "HS256",
       "typ": "JWT"
     }
     ```

2. **페이로드(Payload)**  
   - 실제 담고자 하는 **사용자 정보**(Claims)가 들어가는 부분이다.  
   - 예를 들어, 사용자 ID, 이메일, 발급 시간, 만료 시간 등을 포함할 수 있다.  
   - 역시 JSON 형태이며, Base64Url로 인코딩된다.  
   - 대표적인 클레임(Claim) 종류:  
     - **등록된 클레임(Registered Claims)**: `iss`(토큰 발급자), `sub`(토큰 제목), `aud`(토큰 대상자), `exp`(만료), `iat`(발급 시각) 등  
     - **공개 클레임(Public Claims)**: 충돌 가능성을 방지하기 위해 URI 형식으로 이름을 짓는 클레임  
     - **전용 클레임(Private Claims)**: 발급자와 수신자 간에 임의로 정의한 클레임
   - 예시:
     ```json
     {
       "sub": "1234567890",
       "name": "John Doe",
       "admin": true,
       "iat": 1516239022
     }
     ```

3. **서명(Signature)**  
   - 헤더와 페이로드를 합친 문자열을 HMAC이나 RSA, ECDSA 등의 알고리즘을 이용해 생성한 서명 값이다.  
   - 이를 통해 **토큰의 무결성**(Integrity)과 **신뢰성**을 보장한다.  
   - 예를 들어 **HMAC SHA256**인 경우:  
     ```
     signature = HMACSHA256(
       base64UrlEncode(header) + "." + base64UrlEncode(payload),
       secret
     )
     ```

---

## 2. JWT 동작 원리

1. **사용자 인증(로그인)**  
   - 클라이언트가 ID/비밀번호 등으로 서버에 로그인 요청을 한다.  
   - 서버는 자격 증명을 확인한 뒤, 사용자 정보(예: user_id) 및 만료 시각(`exp`) 등 필요한 클레임을 담아 JWT를 생성(서명 포함)하고 클라이언트에게 반환한다.

2. **클라이언트 저장**  
   - 클라이언트(브라우저, 모바일 앱)는 받은 JWT를 로컬 스토리지나 쿠키 등 보안이 보장된 장소에 저장한다.

3. **요청 시 토큰 전송**  
   - 클라이언트는 이후 API를 호출할 때 `Authorization: Bearer <JWT>` 헤더나 쿠키에 JWT를 첨부해 전송한다.

4. **서버에서 토큰 검증**  
   - 서버는 전달받은 JWT를 헤더, 페이로드, 서명을 분리하고, 헤더에 명시된 알고리즘과 서버의 비밀키(secret) 또는 공개키(RSA/ECDSA의 경우)를 사용해 서명을 검증한다.  
   - 검증이 성공하면 토큰이 조작되지 않았음을 의미하며, 또한 `exp`(만료) 같은 클레임을 확인해 유효 기간 내인지 확인한다.  
   - 유효한 경우, 페이로드 안의 사용자 ID 등을 추출하여 해당 사용자가 인증되었음을 인지하고 요청을 처리한다.

5. **서버 비상 저장 필요 없음**  
   - JWT 자체에 사용자 정보와 서명이 포함되어 있으므로, 서버가 세션과 같은 상태를 저장할 필요가 없다(Stateless).  
   - 다만, 필요에 따라 토큰 블랙리스트나 강제 만료 로직을 지원하기 위해 어느 정도 서버 측 보관이 필요한 경우도 있다.

---

## 3. JWT의 장점과 단점

### 3.1 장점

1. **서버 확장성 향상 (Stateless)**  
   - 서버가 세션 상태를 별도로 저장하지 않아도 되므로, 수평 확장(로드 밸런싱) 및 분산 환경에서 유리하다.

2. **범용성**  
   - JSON 기반이라 시스템 간 상호운용성이 높다.  
   - 다양한 프로그래밍 언어에서 쉽게 파싱/검증이 가능하다.

3. **자체 인증 정보**  
   - 토큰에 인증/권한 정보가 담겨 있어, 다른 마이크로서비스에서도 동일한 토큰으로 인증이 가능(SSO 구현 용이).

4. **보안 및 무결성**  
   - 서명을 검증해 토큰이 변조되지 않았음을 보장할 수 있다(단, 전송 시 HTTPS 사용은 필수).

### 3.2 단점 및 주의사항

1. **토큰 탈취 시 위험**  
   - JWT가 노출되면 만료 시점까지 아무나 사용할 수 있다(세션 무효화가 어렵다는 문제).  
   - HTTPS로 전송을 보호하고, XSS 등으로부터 토큰 보관을 안전하게 해야 한다.

2. **토큰 만료 전 강제 무효화 어려움**  
   - 한 번 발급된 JWT는 만료 시각 전까지 유효하므로, 사용자의 권한이 바뀌거나 토큰을 강제 만료하고 싶을 때 문제가 생긴다.  
   - 이를 해결하기 위해 토큰 블랙리스트나 토큰 재발행(Refresh Token) 기법을 사용해야 한다.

3. **크기 부담**  
   - JWT는 헤더+페이로드+서명으로 인해 세션 쿠키보다 크기가 커질 수 있으며, 빈번히 전송 시 트래픽이 증가할 수 있다.

4. **보안 취약점**  
   - 잘못된 알고리즘(`alg=none` 같은 경우)를 허용하거나, Secret 관리가 허술하면 위험해진다.  
   - 발급 시 꼭 안전한 알고리즘과 충분히 긴 Secret Key(혹은 비대칭키) 사용이 필수이다.

---

## 4. JWT 사용 시 주요 시나리오

1. **웹/모바일 로그인 인증**  
   - 사용자 로그인 성공 시 JWT를 발급하며, 이후 API 호출마다 헤더에 `Bearer <token>`를 포함해야 한다.  
   - 서버는 매 요청마다 토큰 유효성 확인 후 접근 허용한다.

2. **마이크로서비스 간 인증**  
   - 한 서비스에서 발급한 JWT로, 다른 서비스가 요청 받았을 때 토큰 서명을 검증만 하면 인증 상태를 알 수 있어, 각 서비스 간 세션 공유 필요 없이 인증 연동이 가능하다.

3. **소셜 로그인, SSO(Single Sign-On)**  
   - 구글, 페이스북 등 외부 OAuth 서버가 발급하는 JWT(ID Token)로 사용자 정보를 확인이 가능하다.  
   - 사내 여러 애플리케이션에서 단일 로그인 토큰으로 사용이 가능하다.

4. **서버리스, IoT 등 무상태 환경**  
   - Redis 같은 세션 저장소가 없이 단일 토큰을 기반으로 인증/인가를 수행하는 환경에 적합하다.

---

## 5. Refresh Token과의 조합

- **Access Token**(JWT)은 만료 시간이 비교적 짧게 설정(예: 30분~1시간)하여 탈취 위험을 줄인다.  
- **Refresh Token**은 만료 시간을 더 길게(며칠~몇 주) 두어, Access Token이 만료되었을 때 갱신받을 수 있도록 한다.  
- Refresh Token은 서버 DB나 Redis 등에 보관해 강제 무효화할 수 있도록 관리하는 방식도 존재한다.

---

## 6. 보안 고려사항

1. **HTTPS 사용 필수**  
   - 토큰이 평문으로 노출되면 가로채기에 취약하므로, SSL/TLS로 암호화된 연결이 반드시 필요하다.

2. **토큰 저장 위치**  
   - 브라우저 환경에서는 XSS 공격에 노출되지 않도록 **HttpOnly 쿠키** 사용이 권장된다.  
   - 로컬 스토리지에 저장 시, 스크립트로 접근 가능한 영역이므로 XSS에 취약할 수 있다.

3. **적절한 만료 시간**  
   - 너무 긴 만료 시간은 보안 리스크가 커지고, 너무 짧으면 사용자 불편이 커진다. 서비스 특성에 맞게 설정해야 한다.

4. **서명 알고리즘 및 키 관리**  
   - HMAC이든 RSA든 강력한 키를 사용하고, 유출되지 않도록 안전하게 관리해야 한다.  
   - `alg=none` 공격에 대비하여, 반드시 허용 가능한 알고리즘을 명시하고 검증해야 한다.

5. **쿠키 속성**  
   - 쿠키 사용 시 `Secure`, `HttpOnly`, `SameSite` 등의 속성을 적절히 설정해 세션하이재킹, CSRF 등을 방지한다.

---

## 7. 결론

&emsp;JSON Web Token(JWT)은 **토큰 기반 인증**을 구현하는 데 널리 사용되는 표준 기술로, **Stateless**하고, **서명**을 통해 **무결성**을 검증할 수 있어 **분산 환경**, **마이크로서비스**, **모바일**, **서버리스** 등 다양한 시나리오에서 인기가 높다.  
- JWT 토큰에는 **사용자 식별 정보**와 **만료 시간**, **서명**이 포함되어, 클라이언트는 매 요청마다 토큰을 전송해 별도의 서버 측 세션 저장 없이도 인증을 유지할 수 있다.  
- 단, 탈취 시 악용 위험, 강제 만료의 어려움 등 단점이 있으므로 **Refresh Token 전략**, **HTTPS 보안**, **토큰 보관 위치와 만료 시간 관리** 등 추가 보안 대책을 마련해야 한다.

&emsp;이처럼 JWT는 **분산 환경에서의 인증**을 간편하게 해주지만, **세심한 설계**와 **보안 고려**가 뒤따라야 제대로 된 안전성, 확장성을 누릴 수 있는 솔루션이 비로소 될 수가 있다.